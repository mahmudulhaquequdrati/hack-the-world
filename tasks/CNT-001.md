# CNT-001: Create Unified Content Model (SERVER)

## 📋 Task Overview

**Task ID**: CNT-001
**Title**: Create Unified Content Model (SERVER)
**Priority**: 🟡 High
**Status**: 📋 Not Started
**Assignee**: Developer
**Due Date**: January 18, 2025
**Estimated Hours**: 2-3 hours

## 🎯 Objective

Create a simplified, unified Content model that handles all types of content (videos, labs, games, documents) within modules. This replaces the need for separate Video, Lab, Game, and Document models, making the system much simpler to maintain and extend. The content will be displayed in the frontend in a list of sections, each with a title and a list of content items. when adding a new content item, the section will be automatically created if it doesn't exist or we have to add it to an existing section.

## 📊 Simplified Content Structure

```
Module
└── Content (unified model)
    ├── type: 'video' | 'lab' | 'game' | 'document'
    ├── title: string
    ├── description: string
    ├── url?: string (for videos)
    ├── instructions?: string (for labs/games)
    ├── section: string
    ├── duration?: number (in minutes)
    └── metadata: object (flexible for future use)
```

## 🔧 Technical Implementation

### Content Model Schema

```javascript
// server/src/models/Content.js
const mongoose = require("mongoose");

const ContentSchema = new mongoose.Schema(
  {
    id: {
      type: String,
      required: [true, "Content ID is required"],
      unique: true,
    },
    moduleId: {
      type: String,
      required: [true, "Module ID is required"],
      ref: "Module",
    },
    type: {
      type: String,
      required: [true, "Content type is required"],
      enum: ["video", "lab", "game", "document"],
      lowercase: true,
    },
    title: {
      type: String,
      required: [true, "Content title is required"],
      trim: true,
      maxlength: [100, "Title cannot exceed 100 characters"],
    },
    description: {
      type: String,
      required: [true, "Content description is required"],
      trim: true,
      maxlength: [500, "Description cannot exceed 500 characters"],
    },
    // For videos
    url: {
      type: String,
      required: function () {
        return this.type === "video";
      },
      validate: {
        validator: function (v) {
          if (this.type === "video") {
            return /^https?:\/\/.+/.test(v);
          }
          return true;
        },
        message: "URL must be a valid HTTP/HTTPS URL for videos",
      },
    },
    // For labs and games
    instructions: {
      type: String,
      required: function () {
        return this.type === "lab" || this.type === "game";
      },
      maxlength: [2000, "Instructions cannot exceed 2000 characters"],
    },
    section: {
      type: String,
      required: [true, "Content section is required"],
      maxlength: [100, "Section cannot exceed 100 characters"],
    },
    duration: {
      type: Number,
      min: [1, "Duration must be at least 1 minute"],
      max: [300, "Duration cannot exceed 300 minutes"],
    },
    metadata: {
      type: mongoose.Schema.Types.Mixed,
      default: {},
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Indexes for performance
ContentSchema.index({ moduleId: 1, section: 1 });
ContentSchema.index({ type: 1 });
ContentSchema.index({ id: 1 }, { unique: true });

// Virtual for content URL (for frontend routing)
ContentSchema.virtual("contentUrl").get(function () {
  return `/learn/${this.moduleId}/${this.type}/${this.id}`;
});

// Static method to get content by module
ContentSchema.statics.getByModule = function (moduleId) {
  return this.find({ moduleId, isActive: true }).sort({ section: 1 });
};

// Static method to get content by type
ContentSchema.statics.getByType = function (type, moduleId = null) {
  const query = { type, isActive: true };
  if (moduleId) query.moduleId = moduleId;
  return this.find(query).sort({ section: 1 });
};

module.exports = mongoose.model("Content", ContentSchema);
```

## 📝 Seed Data Structure

```javascript
// server/src/data/contentData.js
const CONTENT_DATA = [
  // Beginner Module Content
  {
    id: "basic-cybersec-intro-video",
    moduleId: "basic-cybersec",
    type: "video",
    title: "Introduction to Cybersecurity",
    description: "Learn the fundamentals of cybersecurity and why it matters",
    url: "https://example.com/videos/cybersec-intro",
    section: "Introduction",
    duration: 15,
    metadata: {
      difficulty: "beginner",
      tags: ["introduction", "fundamentals"],
    },
  },
  {
    id: "basic-cybersec-password-lab",
    moduleId: "basic-cybersec",
    type: "lab",
    title: "Password Security Lab",
    description: "Hands-on practice with password security techniques",
    instructions:
      "Create strong passwords and test their strength using security tools.",
    section: "Password Security",
    duration: 30,
    metadata: {
      difficulty: "beginner",
      tools: ["password-checker", "hash-generator"],
    },
  },
  {
    id: "basic-cybersec-phishing-game",
    moduleId: "basic-cybersec",
    type: "game",
    title: "Phishing Detection Game",
    description: "Interactive game to identify phishing attempts",
    instructions:
      "Analyze emails and websites to identify phishing attempts. Score points for correct identifications.",
    section: "Phishing Detection",
    duration: 20,
    metadata: {
      difficulty: "beginner",
      scoring: { correct: 10, incorrect: -5 },
    },
  },
  // Add more content for other modules...
];

module.exports = { CONTENT_DATA };
```

## 🧪 Testing Requirements

### Unit Tests

```javascript
// server/src/tests/models/Content.test.js
describe("Content Model", () => {
  beforeEach(async () => {
    await Content.deleteMany({});
  });

  describe("Content Creation", () => {
    it("should create a valid video content", async () => {
      const contentData = {
        id: "test-video",
        moduleId: "test-module",
        type: "video",
        title: "Test Video",
        description: "Test description",
        url: "https://example.com/video",
        section: "Introduction",
        duration: 10,
      };

      const content = new Content(contentData);
      const savedContent = await content.save();

      expect(savedContent._id).toBeDefined();
      expect(savedContent.type).toBe("video");
      expect(savedContent.url).toBe(contentData.url);
    });

    it("should create a valid lab content", async () => {
      const contentData = {
        id: "test-lab",
        moduleId: "test-module",
        type: "lab",
        title: "Test Lab",
        description: "Test description",
        instructions: "Test instructions for the lab",
        section: "Password Security",
        duration: 30,
      };

      const content = new Content(contentData);
      const savedContent = await content.save();

      expect(savedContent._id).toBeDefined();
      expect(savedContent.type).toBe("lab");
      expect(savedContent.instructions).toBe(contentData.instructions);
    });

    it("should create a valid game content", async () => {
      const contentData = {
        id: "test-game",
        moduleId: "test-module",
        type: "game",
        title: "Test Game",
        description: "Test description",
        instructions: "Test instructions for the game",
        section: "Phishing Detection",
        duration: 15,
      };

      const content = new Content(contentData);
      const savedContent = await content.save();

      expect(savedContent._id).toBeDefined();
      expect(savedContent.type).toBe("game");
      expect(savedContent.instructions).toBe(contentData.instructions);
    });
  });

  describe("Content Validation", () => {
    it("should require URL for video content", async () => {
      const contentData = {
        id: "test-video",
        moduleId: "test-module",
        type: "video",
        title: "Test Video",
        description: "Test description",
        section: "Introduction",
        // Missing required url
      };

      const content = new Content(contentData);
      await expect(content.save()).rejects.toThrow();
    });

    it("should require instructions for lab content", async () => {
      const contentData = {
        id: "test-lab",
        moduleId: "test-module",
        type: "lab",
        title: "Test Lab",
        description: "Test description",
        section: "Password Security",
        // Missing required instructions
      };

      const content = new Content(contentData);
      await expect(content.save()).rejects.toThrow();
    });

    it("should validate content type enum", async () => {
      const contentData = {
        id: "test-content",
        moduleId: "test-module",
        type: "invalid-type",
        title: "Test Content",
        description: "Test description",
        section: "Introduction",
      };

      const content = new Content(contentData);
      await expect(content.save()).rejects.toThrow();
    });
  });

  describe("Content Queries", () => {
    beforeEach(async () => {
      // Create test content
      await Content.create([
        {
          id: "content-1",
          moduleId: "module-1",
          type: "video",
          title: "Video 1",
          description: "Description 1",
          url: "https://example.com/video1",
          section: "Introduction",
        },
        {
          id: "content-2",
          moduleId: "module-1",
          type: "lab",
          title: "Lab 1",
          description: "Description 2",
          instructions: "Lab instructions",
          section: "Password Security",
        },
        {
          id: "content-3",
          moduleId: "module-2",
          type: "game",
          title: "Game 1",
          description: "Description 3",
          instructions: "Game instructions",
          section: "Phishing Detection",
        },
      ]);
    });

    it("should get content by module", async () => {
      const content = await Content.getByModule("module-1");
      expect(content).toHaveLength(2);
      expect(content[0].section).toBeLessThan(content[1].section);
    });

    it("should get content by type", async () => {
      const videos = await Content.getByType("video");
      expect(videos).toHaveLength(1);
      expect(videos[0].type).toBe("video");
    });

    it("should get content by type and module", async () => {
      const labs = await Content.getByType("lab", "module-1");
      expect(labs).toHaveLength(1);
      expect(labs[0].type).toBe("lab");
      expect(labs[0].moduleId).toBe("module-1");
    });
  });
});
```

## 📚 Integration Points

### Module Integration

- Content belongs to a Module (foreign key relationship)
- Update Module model to include content count virtual field
- Ensure cascade deletion when module is removed

### User Progress Integration

- Content will be referenced in UserProgress model
- Track completion status per content item
- Calculate module progress based on completed content

## 🎯 Success Criteria

- [ ] Content model created with proper schema validation
- [ ] All three content types (video, lab, game) supported
- [ ] Proper indexing for performance
- [ ] Static methods for common queries implemented
- [ ] Comprehensive unit tests written (100% coverage)
- [ ] Content seed data created for testing
- [ ] Integration with existing Module model verified
- [ ] Model exported and ready for API integration

## 🔗 Dependencies

**Depends on**: SRV-002 (Seed Scripts Setup)
**Blocks**: API-001 (Content API Endpoints)

## 📖 Notes

- This unified approach replaces the need for CNT-002 through CNT-006 tasks
- Metadata field allows for future extensions without schema changes
- Type-based validation ensures content integrity
- Order field enables proper content sequencing within modules
- Virtual fields provide convenient frontend integration points

**Benefits of Unified Approach**:

- Single model to maintain instead of 4+ separate models
- Consistent API interface for all content types
- Easier to add new content types in the future
- Simplified frontend component architecture
- Reduced database complexity and faster queries
